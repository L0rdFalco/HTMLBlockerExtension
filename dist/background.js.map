{"version":3,"file":"background.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACLA;AAAA;AAAA;AADA;AAEA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAEA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAGA;AAEA;AAGA;AAEA;AAGA;AACA;AACA;AACA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAEA;AAEA;AAEA;AAEA;AAEA;AAGA;AAEA;AAEA;AAEA;;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAGA;AAIA;AACA;AAIA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAIA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAHA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA","sources":["webpack://htmlblocker/./node_modules/logging/lib/browser.js","webpack://htmlblocker/./node_modules/idb-keyval/dist/index.js","webpack://htmlblocker/webpack/bootstrap","webpack://htmlblocker/webpack/runtime/define property getters","webpack://htmlblocker/webpack/runtime/hasOwnProperty shorthand","webpack://htmlblocker/webpack/runtime/make namespace object","webpack://htmlblocker/./src/background.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n// Super basic browser support just to avoid breaking universal builds.\n// title and log level are not included in the output at this time.\nvar logger = function logger() {\n    var _console;\n\n    return (_console = console).log.apply(_console, arguments);\n};\n\nfunction createLogger() /* title */{\n    return {\n        info: logger,\n        warn: logger,\n        error: logger,\n        debug: logger\n    };\n}\n\nexports.default = createLogger;","function promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n        // @ts-ignore - file size hacks\n        request.oncomplete = request.onsuccess = () => resolve(request.result);\n        // @ts-ignore - file size hacks\n        request.onabort = request.onerror = () => reject(request.error);\n    });\n}\nfunction createStore(dbName, storeName) {\n    const request = indexedDB.open(dbName);\n    request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n    const dbp = promisifyRequest(request);\n    return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));\n}\nlet defaultGetStoreFunc;\nfunction defaultGetStore() {\n    if (!defaultGetStoreFunc) {\n        defaultGetStoreFunc = createStore('keyval-store', 'keyval');\n    }\n    return defaultGetStoreFunc;\n}\n/**\n * Get a value by its key.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction get(key, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => promisifyRequest(store.get(key)));\n}\n/**\n * Set a value with a key.\n *\n * @param key\n * @param value\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction set(key, value, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.put(value, key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Set multiple values at once. This is faster than calling set() multiple times.\n * It's also atomic â€“ if one of the pairs can't be added, none will be added.\n *\n * @param entries Array of entries, where each entry is an array of `[key, value]`.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction setMany(entries, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        entries.forEach((entry) => store.put(entry[1], entry[0]));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Get multiple values by their keys\n *\n * @param keys\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction getMany(keys, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => Promise.all(keys.map((key) => promisifyRequest(store.get(key)))));\n}\n/**\n * Update a value. This lets you see the old value and update it as an atomic operation.\n *\n * @param key\n * @param updater A callback that takes the old value and returns a new value.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction update(key, updater, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => \n    // Need to create the promise manually.\n    // If I try to chain promises, the transaction closes in browsers\n    // that use a promise polyfill (IE10/11).\n    new Promise((resolve, reject) => {\n        store.get(key).onsuccess = function () {\n            try {\n                store.put(updater(this.result), key);\n                resolve(promisifyRequest(store.transaction));\n            }\n            catch (err) {\n                reject(err);\n            }\n        };\n    }));\n}\n/**\n * Delete a particular key from the store.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction del(key, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.delete(key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Delete multiple keys at once.\n *\n * @param keys List of keys to delete.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction delMany(keys, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        keys.forEach((key) => store.delete(key));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Clear all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction clear(customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.clear();\n        return promisifyRequest(store.transaction);\n    });\n}\nfunction eachCursor(store, callback) {\n    store.openCursor().onsuccess = function () {\n        if (!this.result)\n            return;\n        callback(this.result);\n        this.result.continue();\n    };\n    return promisifyRequest(store.transaction);\n}\n/**\n * Get all keys in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction keys(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAllKeys) {\n            return promisifyRequest(store.getAllKeys());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);\n    });\n}\n/**\n * Get all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction values(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAll) {\n            return promisifyRequest(store.getAll());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.value)).then(() => items);\n    });\n}\n/**\n * Get all entries in the store. Each entry is an array of `[key, value]`.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction entries(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        // (although, hopefully we'll get a simpler path some day)\n        if (store.getAll && store.getAllKeys) {\n            return Promise.all([\n                promisifyRequest(store.getAllKeys()),\n                promisifyRequest(store.getAll()),\n            ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]));\n        }\n        const items = [];\n        return customStore('readonly', (store) => eachCursor(store, (cursor) => items.push([cursor.key, cursor.value])).then(() => items));\n    });\n}\n\nexport { clear, createStore, del, delMany, entries, get, getMany, keys, promisifyRequest, set, setMany, update, values };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { get, set, update } from 'idb-keyval';\n\nimport createLogger from 'logging';\n\nconst logger = createLogger('bgScript');\n\n\nlet allowed = true;\n\nlet prefs = {\n  showContextMenu: false,\n  autoRefresh: true,\n  allProtocols: false,\n  allSubdomains: false,\n  allPorts: false,\n  lightIcon: false,\n  darkIcon: false,\n  defaultIcon: true\n}\n\nlet forbiddenOrigin = /(chrome\\:\\/\\/)/g;\nlet rules = [];\nlet contextMenuId = null;\nlet incognito;\nlet url;\nlet tabId;\n\n\nfunction onIcon() {\n  chrome.action.setIcon({ path: \"./icons/icon16_on.png\" });\n  chrome.action.setTitle({ title: \"ON\" })\n\n}\n\nfunction offIcon() {\n  chrome.action.setIcon({ path: \"./icons/icon16_off.png\" });\n  chrome.action.setTitle({ title: \"OFF\" });\n\n}\n\nfunction noIcon() {\n\n  chrome.action.setIcon({ path: \"./icons/icon16_no.png\" });\n  chrome.action.setTitle({ title: \"NO!\" })\n\n  return\n}\n\nasync function isSiteViable() {\n  let tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n  if (!tabs || !tabs.length || tabs[0].id < 0) return;\n\n  return tabs[0];\n\n}\n\nasync function areToolsLoaded() {\n\n  try {\n    let mTab = await isSiteViable(); // execution stops if there's no tab object\n\n    if (!mTab.url.startsWith(\"http\")) return noIcon(); // execution stops after icon is set\n\n    let visibStatus = await chrome.tabs.sendMessage(mTab.id, { action: \"getStatus\" });\n\n\n    visibStatus ? onIcon() : offIcon();\n\n  } catch (error) {\n    console.log(\"blocking status error\");\n\n    noIcon()\n\n  }\n\n}\n\n\nasync function toggleTools(mTabID) {\n\n  try {\n    return await chrome.tabs.sendMessage(mTabID, { action: \"toggle\", status: allowed })\n\n  } catch (error) {\n    console.log(\"toggle error\");\n\n    noIcon()\n\n  }\n\n\n}\n\nasync function forceInjectCS(mTab) {\n\n  try {\n\n    return await chrome.scripting.executeScript({ files: [\"content_script.js\"], target: { tabId: mTab.id } });\n  } catch (error) {\n    console.log(\"the webpage is probably forbidding script injection\");\n    noIcon()\n\n  }\n\n\n}\n\nchrome.runtime.onInstalled.addListener(function (details) {\n  areToolsLoaded()\n\n  imgBlockingInit()\n\n  if (details.reason === \"install\" || details.reason === \"update\") {\n    (async () => {\n\n      logger.info('installed');\n\n    })();\n  }\n\n  if (details.reason === \"install\") {\n    setContentRules()\n  }\n\n  if (details.reason === \"update\") {\n    setContentRules()\n  }\n\n});\n\nchrome.runtime.onStartup.addListener(() => {\n  areToolsLoaded()\n\n  imgBlockingInit()\n})\n\nchrome.windows.onFocusChanged.addListener(() => {\n  areToolsLoaded()\n\n  getTabData()\n\n})\n\nchrome.action.onClicked.addListener(async function () {\n  try {\n    const mTab = await isSiteViable();\n\n    const res = await toggleTools(mTab.id)\n\n    if (!res) { // in the event the browser didn't inject the CS from the jump\n      let res = await forceInjectCS(mTab)\n\n      if (!res) return\n      await toggleTools(mTab.id)\n\n    }\n\n  } catch (error) {\n\n    console.log(\"icon click error\");\n\n  }\n\n\n})\n\nchrome.tabs.onActivated.addListener((tabId, changeInfo, tab) => {\n  areToolsLoaded()\n  getTabData()\n\n})\n\nchrome.tabs.onUpdated.addListener((msg, sender, res) => {\n\n  areToolsLoaded()\n\n  getTabData()\n\n})\n\n\nchrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {\n\n  if (msg.action === \"toolsVisibStatus\") msg.visible ? onIcon() : offIcon()\n\n  else if (msg.action === \"persist_perm_hidden_elms\") {\n    set(`web:${msg.website}`, msg.data);\n\n  }\n\n  else if (msg.action === \"extract_perm_hidden_elms\") {\n    get(`web:${msg.website}`).then(data => {\n      sendResponse(data || \"[]\")\n    })\n  }\n\n  else if (msg.action === \"toggle_images\") {\n    console.log(\"toggle images\");\n\n    (async function () {\n      await toggleImageBlocking()\n\n    })()\n\n  }\n  else if (msg.action === \"toggleContextMenu\") {\n    toggleContextMenu()\n\n  }\n  else if (msg.action === \"openImgPanel\") {\n    openImgPanel()\n\n  }\n  else if (msg.action === \"clearRules\") {\n    clearRules(msg.scope)\n\n\n  }\n  else if (msg.action === \"setContentRules\") {\n    setContentRules(msg.rules)\n\n  }\n  else if (msg.action === \"sendData\") {\n    // Process the request and send back a response\n\n    chrome.storage.local.set({ dId: msg.id }, () => {\n\n      sendResponse({ success: true, data: \"db info saved!\" });\n    })\n\n\n  }\n\n\n\n  return true\n})\n\n\n\nchrome.contextMenus.onClicked.addListener((info, tab) => {\n  if (info.menuItemId === \"imgContextMenu\") openImgPanel()\n})\n\nasync function getTabData() {\n  //extracts required tab data\n\n  try {\n    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n\n    const tab = tabs[0];\n\n    if (tab) {\n      incognito = tab.incognito;\n      url = tab.url;\n      tabId = tab.id;\n\n      return [url ? url : null, incognito, tabId ? tabId : null]\n    }\n\n    else {\n      console.log(\"no active tab\");\n\n      return []\n\n    }\n\n  } catch (error) {\n    console.log(\"getTabData error\");\n  }\n\n}\n\nfunction openImgPanel() {\n  chrome.tabs.create({ url: \"chrome://settings/content/images\", active: true });\n\n}\n\nasync function toggleImageBlocking() {\n\n  const res = await getTabData()\n\n  if (!res[0]) return // when there's no url\n  if (!res[2]) return // when theres no tabId\n  if (res[0].match(forbiddenOrigin)) return // when its a forbidden page\n\n  const ImgsRes = await chrome.contentSettings.images.get({ primaryUrl: res[0], incognito: res[1] });\n\n  let setting = ImgsRes.setting;\n  if (!setting) return;\n\n  const urlParser = new URL(res[0])\n\n  let pattern = /^file:/.test(url) ? url : `${urlParser.hostname}/*`;\n  if (!/^file:/.test(url)) { // when url is a live link and not a local file\n    prefs.allProtocols = false; //brute force removal of unneeded flag\n    pattern = prefs.allProtocols ? '*://' : `${urlParser.protocol}//`;\n    const domParts = urlParser.hostname.split('.');\n    if (prefs.allSubdomains && domParts.length > 2) {\n      while (domParts.length > 2) {\n        domParts.shift();\n      }\n      pattern += `*.${domParts.join('.')}`;\n    } else {\n      pattern += urlParser.hostname;\n    }\n    pattern += prefs.allPorts ? ':*' : (urlParser.port ? `:${urlParser.port}` : '');\n    pattern += '/*';\n  }\n\n  const newSetting = setting === \"allow\" ? \"block\" : \"allow\"\n\n  chrome.contentSettings.images.set({\n    primaryPattern: pattern,\n    setting: newSetting,\n    scope: incognito ? \"incognito_session_only\" : \"regular\"\n  })\n\n  if (prefs.autoRefresh) {\n    chrome.tabs.reload(res[2], { bypassCache: true })\n  }\n\n  setLocalStorageRule(pattern, newSetting, res[1])\n\n\n\n}\n\nasync function setLocalStorageRule(pattern, newSetting, incognito) {\n\n  if (incognito) return\n\n  const data = await chrome.storage.local.get(\"imgTF_rules\")\n\n  let rules = data.imgtf_rules || []\n  let keyExist = false;\n\n  if (rules.length) { //check if  current url + blocking status is saved in storage\n    for (let i = 0; i < rules.length; i++) {\n      if (pattern === rules[i].primaryPattern) {\n        rules[i].setting = newSetting;\n        keyExist = true;\n        break;\n      }\n\n    }\n  }\n\n  if (!keyExist) {\n    rules.push({\n      primaryPattern: pattern,\n      setting: newSetting,\n      scope: incognito ? 'incognito_session_only' : 'regular'\n    });\n  }\n\n  chrome.storage.local.set({ imgTF_rules: rules })\n\n\n}\n\nfunction toggleContextMenu() {\n  if (prefs.showContextMenu && !contextMenuId) {\n    contextMenuId = chrome.contextMenus.create({\n      id: \"imgContextMenu\",\n      title: \"settings-> img exceptions\",\n      type: \"normal\",\n      contexts: [\"all\"]\n    })\n\n  }\n\n  if (!prefs.showContextMenu && contextMenuId) {\n    chrome.contextMenus.remove(contextMenuId)\n    contextMenuId = null;\n\n  }\n\n}\n\nasync function setContentRules(sentRules) {\n  if (sentRules) rules = sentRules\n\n  if (rules.length) {\n    for (let i = 0; i < rules.length; i++) {\n\n      chrome.contentSettings.images.set({\n        primaryPattern: rules[i].primaryPattern,\n        setting: rules[i].setting,\n        scope: rules[i].scope\n      })\n    }\n\n  }\n  chrome.storage.local.set({ imgTF_rules: rules })\n\n}\n\nasync function imgBlockingInit() {\n\n  toggleContextMenu();\n  console.log(\"1\");\n  let data = await chrome.storage.local.get(['img_on_off_prefs', 'imgTF_rules'])\n\n  prefs = data.image_on_off_prefs || prefs;\n  rules = data.imgTF_rules || rules;\n\n  await setContentRules(rules)//importRules\n\n  await getTabData();//getSettings\n\n}\n\n"],"names":[],"sourceRoot":""}